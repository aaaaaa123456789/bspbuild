#include "proto.h"

/*
   Patch format:
   1 byte: patch engine ID (bits 0-6), reversible patch flag (bit 7)
   If the patch is reversible, 4 bytes: pointer to reverse patch (generated by patch module)
   Data (interpreted by the engine)
*/

void define_apply_patch_function (void) {
  add_declared_label_to_codefile(builder_state -> codefile, get_label(apply_patch, "ApplyPatch"));
  inst(INST_GETBYTEINC, reg(result), reg(argument));
  inst(INST_IFLT, reg(result), imm(0x80), lbl(execute_patch, "ExecutePatch"));
  inst(INST_AND2, reg(result), imm(0x7f));
  inst(INST_ADD2, reg(argument), imm(4));
  inst(INST_JUMP, lbl(execute_patch, "ExecutePatch"));
  add_blank_line_to_codefile(builder_state -> codefile);
}

void define_apply_reverse_patch_function (void) {
  add_declared_label_to_codefile(builder_state -> codefile, get_label(apply_reverse_patch, "ApplyReversePatch"));
  inst(INST_GETBYTEINC, reg(result), reg(argument));
  inst(INST_IFLT, reg(result), imm(0x80), loc("not_reversible"));
  inst(INST_AND2, reg(result), imm(0x7f));
  inst(INST_GETWORD, reg(argument), reg(argument));
  inst(INST_JUMP, lbl(execute_patch, "ExecutePatch"));
  add_blank_line_to_codefile(builder_state -> codefile);
  builder_declare_local("not_reversible");
  inst(INST_SET, reg(argument), err(CODE_ERROR_PATCH_NOT_REVERSIBLE));
  inst(INST_JUMP, lbl(error, "Error"));
  add_blank_line_to_codefile(builder_state -> codefile);
}

void define_execute_patch_function (void) {
  add_declared_label_to_codefile(builder_state -> codefile, get_label(execute_patch, "ExecutePatch"));
  inst(INST_JUMPTABLE, reg(result)); // engine ID is in #result (patch pointer in #argument)
  unsigned char engine;
  for (engine = 0; engine < builder_state -> patch_engines.count; engine ++)
    inst(INST_DW, ARGTYPE_GLOBAL_LABEL, builder_state -> patch_engines.labels[engine]); // no point in defining a macro for an argument type only used here
  add_blank_line_to_codefile(builder_state -> codefile);
}

void define_patch_engine_functions (void) {
  unsigned char current;
  for (current = 0; current < builder_state -> patch_engines.count; current ++) {
    add_declared_label_to_codefile(builder_state -> codefile, builder_state -> patch_engines.labels[current]);
    patch_engine_generator_functions[builder_state -> patch_engines.methods[current]]();
    add_blank_line_to_codefile(builder_state -> codefile);
  }
  if (builder_state -> needed_functions.pad_to_length) define_pad_to_length_function();
  // ...
}
