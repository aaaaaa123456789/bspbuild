# bspbuild documentation

bspbuild is a utility that aims to automatically create [BSP patches][bsp] automatically, removing the need to write
the patch's code manually. The patches created can validate both their inputs and outputs by checking their lengths
and SHA-1 hashes, and allow the user to use multiple input files and/or to select one of many possible outputs. The
data contained in the patches themselves may be stored in several different formats, thus allowing the patch creator
to select the best choice for each file involved.

Note that this utility is only concerned with creating patches, not with applying those patches. In order to apply a
patch created by this utility, you will need a BSP patcher, such as the one available [here][patcher].

[bsp]: https://github.com/aaaaaa123456789/bsp
[patcher]: https://aaaaaa123456789.github.io/bsp

## Table of contents

TODO

## Patching basics

### Inputs and outputs

A patch is, in general, a file that describes how to transform one file into another. While these files can be
respectively considered to be the input and output of the patching process, in order to avoid confusion with the
inputs and outputs of bspbuild itself, the remainder of these documentation will refer to these files as the _sources_
and _targets_ of the patch.

Therefore, a patch will contain instructions to turn one or more source files into one or more target files. Note that
patches built by bspbuild may involve more than one source or one target; if this is the case, the user of the patch
will be able to use any of the permitted source files to transform it into any of the target files.

Sources and targets are all treated as _inputs_ by bspbuild. That is because bspbuild must create a patch based on all
of these files; it reads them, but it doesn't write them. On the other hand, the patch is the _output_ of bspbuild.
The BSP source code that generates the patch can also be output by bspbuild.

### Sources and targets

As explained in the previous section, a patch generated by bspbuild may have arbitrarily many sources and targets. Due
to the differences between sources and targets, input files must be marked as sources, targets or both:

* The `-s` command-line option indicates that the input files that follow are source files. The patch will contain
  instructions to convert any of these files into the targets, and will accept any of them as input; however, the
  patch will be unable to regenerate and output these files.
* The `-t` command-line option indicates that the input files that follow are target files. The patch will contain
  instructions to generate any of these files from the sources; however, it will not accept these files as input.
* The `-st` command-line option indicates that the input files that follow are both sources and targets; this is the
  default if nothing is specified. The patch will contain instructions to convert any of these files into the targets,
  as well as instructions to convert any of the sources into these files; in other words, they can be both inputs and
  outputs of the patch. These files will be referred to as source+target files.

Note that, in order to generate a patch, at least one source and one target must be present. Source+target files count
as either. (However, a single source+target file by itself is not enough; there must be at least two input files.)

### Patching chains

If a patch involves multiple sources and targets, all of the targets must be buildable from all of the sources. By
default, this would involve storing information for each combination of source and target. In other words, each target
would require a patch that allows building it from every source â€” such a patch is often called a _rainbow patch_ in
the source code. This is undesirable due to space constraints.

In order to avoid creating rainbow patches when there is no need, bspbuild creates a _patching chain_. This chain
contains all source, source+target and target files in that order; for every file in the chain, a patch is stored
that transforms it into the next file in the chain. That way, every target can be built from every source without
having to store rainbow patches for all of them; the patches are applied in sequence and the chain is walked until the
desired file is obtained. Note that the patches involving source+target files are generated in such a way that allows
applying them in reverse, which enables the patch to walk that segment of the patching chain backwards in order to
generate earlier source+target files from later ones.

The fact that source files are involved in the patching chain implies that earlier source files can be transformed
into later ones by applying patches. While the patch doesn't emit these files (it will only emit files marked as
targets, i.e., source+target and target files), it does contain the data to do so. This may be undesirable in some
cases. If this is the case, the `--no-source-to-source` option disables source-to-source patches, removing source
files from the chain; in this case, a rainbow patch will be generated for the very first file in the chain, which may
be a source+target or a target file.

Target files are part of the chain. However, since they cannot ever be inputs to the patching process, a linear chain
is not necessary for them. Therefore, for targets other than the first, it is possible to indicate which file they
should be generated from, creating a tree-like structure at the end of the patching chain:

* The `-tp` option is the default, and indicates that subsequent target files should be generated from the previous
  target file, creating a linear chain.
* The `-tl` option indicates that the previously named target file should be taken as reference for generating all
  subsequent target files.
* The `-ts` option indicates that subsequent target files should be generated directly from the last source file. If
  the `--no-source-to-source` option is enabled and there are no source+target files, this generates rainbow patches
  for all subsequent target files.

Note that all of this options imply `-t`. Also, they can be given multiple times in the command line, each one coming
into force until a new one is given. This way, the end of the patching chain can be manipulated at will.
