# bspbuild documentation

bspbuild is a utility that aims to automatically create [BSP patches][bsp] automatically, removing the need to write
the patch's code manually. The patches created can validate both their inputs and outputs by checking their lengths
and SHA-1 hashes, and allow the user to use multiple input files and/or to select one of many possible outputs. The
data contained in the patches themselves may be stored in several different formats, thus allowing the patch creator
to select the best choice for each file involved.

Note that this utility is only concerned with creating patches, not with applying those patches. In order to apply a
patch created by this utility, you will need a BSP patcher, such as the one available [here][patcher].

[bsp]: https://github.com/aaaaaa123456789/bsp
[patcher]: https://aaaaaa123456789.github.io/bsp

---

## Table of contents

TODO

---

## Patching basics

### Inputs and outputs

A patch is, in general, a file that describes how to transform one file into another. While these files can be
respectively considered to be the input and output of the patching process, in order to avoid confusion with the
inputs and outputs of bspbuild itself, the remainder of these documentation will refer to these files as the _sources_
and _targets_ of the patch.

Therefore, a patch will contain instructions to turn one or more source files into one or more target files. Note that
patches built by bspbuild may involve more than one source or one target; if this is the case, the user of the patch
will be able to use any of the permitted source files to transform it into any of the target files.

Sources and targets are all treated as _inputs_ by bspbuild. That is because bspbuild must create a patch based on all
of these files; it reads them, but it doesn't write them. On the other hand, the patch is the _output_ of bspbuild.
The BSP source code that generates the patch can also be output by bspbuild.

### Sources and targets

As explained in the previous section, a patch generated by bspbuild may have arbitrarily many sources and targets. Due
to the differences between sources and targets, input files must be marked as sources, targets or both:

* The `-s` command-line option indicates that the input files that follow are source files. The patch will contain
  instructions to convert any of these files into the targets, and will accept any of them as input; however, the
  patch will be unable to regenerate and output these files.
* The `-t` command-line option indicates that the input files that follow are target files. The patch will contain
  instructions to generate any of these files from the sources; however, it will not accept these files as input.
* The `-st` command-line option indicates that the input files that follow are both sources and targets; this is the
  default if nothing is specified. The patch will contain instructions to convert any of these files into the targets,
  as well as instructions to convert any of the sources into these files; in other words, they can be both inputs and
  outputs of the patch. These files will be referred to as _source+target files_.

Note that, in order to generate a patch, at least one source and one target must be present. Source+target files count
as either. (However, a single source+target file by itself is not enough; there must be at least two input files.)

### Patching chains

If a patch involves multiple sources and targets, all of the targets must be buildable from all of the sources. By
default, this would involve storing information for each combination of source and target. In other words, each target
would require a patch that allows building it from every source — such a patch is often called a _rainbow patch_ in
the source code. This is undesirable due to space constraints.

In order to avoid creating rainbow patches when there is no need, bspbuild creates a _patching chain_. This chain
contains all source, source+target and target files in that order; for every file in the chain, a patch is stored
that transforms it into the next file in the chain. That way, every target can be built from every source without
having to store rainbow patches for all of them; the patches are applied in sequence and the chain is walked until the
desired file is obtained. Note that the patches involving source+target files are generated in such a way that allows
applying them in reverse, which enables the patch to walk that segment of the patching chain backwards in order to
generate earlier source+target files from later ones.

The fact that source files are involved in the patching chain implies that earlier source files can be transformed
into later ones by applying patches. While the patch doesn't emit these files (it will only emit files marked as
targets, i.e., source+target and target files), it does contain the data to do so. This may be undesirable in some
cases. If this is the case, the `--no-source-to-source` option disables source-to-source patches, removing source
files from the chain; in this case, a rainbow patch will be generated for the very first file in the chain, which may
be a source+target or a target file.

Target files are part of the chain. However, since they cannot ever be inputs to the patching process, a linear chain
is not necessary for them. Therefore, for targets other than the first, it is possible to indicate which file they
should be generated from, creating a tree-like structure at the end of the patching chain:

* The `-tp` option is the default, and indicates that subsequent target files should be generated from the previous
  target file, creating a linear chain.
* The `-tl` option indicates that the previously named target file should be taken as reference for generating all
  subsequent target files.
* The `-ts` option indicates that subsequent target files should be generated directly from the last source file. If
  the `--no-source-to-source` option is enabled and there are no source+target files, this generates rainbow patches
  for all subsequent target files.

Note that all of these options imply `-t`. Also, they can be given multiple times in the command line, each one coming
into force until a new one is given. This way, the end of the patching chain can be manipulated at will.

### Patching methods

A patching method is a specific data format for a patch. In other words, the patching method determines how the patch
data should be stored, and how it should be used to transform a file into another. Every individual patching method
requires a corresponding patching engine in order to apply its patches; bspbuild takes care to include all the
necessary patching engines in the patches it generates. Note that patching methods may have minor differences across
patches built by bspbuild depending on the configuration options passed to it; however, a single patching method will
not show any differences if used multiple times in the same BSP file.

The patching method used to generate each file in the patching chain can be selected by the user; this is true
irrespective of whether a file is a source, source+target or target file. (Files removed from the patching chain by
the `--no-source-to-source` option, as well as the very first source file (or source+target file, if there are no
source files) ignore the selected patching method, as they are never outputs to any patch.

The patching method is selected using the `-m` option (for instance, `-m ips` selects the `ips` patching method); the
selected method applies for all subsequent files until a new method is selected. The available patching methods are:

* `ips`: generates IPS-like patches (modified to allow patches for files larger than 16 MB, as well as patches that
  generate smaller files than the original). These patches are not naturally reversible, which means that a reversible
  IPS patch will be stored as two separate patches.
* `xor`: generates a patch where the data is stored as the XOR between the two files involved. This has the same size
  as the larger of the two files, and is equivalent to encrypting one of the files using the other as key.
* `xor-rle` (default): generates a patch where the data is computed as the XOR between the two files involved, but
  then stored in a format that encodes runs of equal values and arithmetical sequences in a compact format, thus
  usually resulting in a smaller patch.

### Fragmentation and padding

If a file is internally made up of multiple smaller blocks of equal size (called _fragments_), it may be useful to
indicate this fact to the patch builder; this will adapt the patching method to handle each fragment separately. This
allows for smaller and better patches to be generated, particularly when combined with the options explained below.
The fragment size is indicated with the `-f` option; for instance, `-f 16384` indicates that the file should be broken
into 16 KB fragments. (The smallest valid size is 64; however, using this option with fragments smaller than a few
kilobytes in size is not recommended.)

If the target file in question is a file that has been padded up to its current size, this can be indicated to produce
a smaller patch. The options `-pb`, `-ph` and `-pw` respectively accept an 8, 16 or 32-bit value as an argument, and
indicate that the file has been padded with that value; for instance, `-pb 0xff` indicates that the file has been
padded with FF bytes. If fragmentation is enabled, each individual fragment is considered to be padded to length;
therefore, the padding at the end of each fragment may be omitted.

If the fragments in the target file are not in the same order as in the source file, the patching method can be
adapted to take this into account; the `--check-fragment-swap` option does this. This will add an initial pass of
fragment reordering before applying the patch.

Note that patching methods may or may not take the information given by these options into account; for instance, the
`ips` method ignores it. Also note that misuse of these options will not generate incorrect patches — these options
are intended as optimizations to produce smaller and faster patches, but using them incorrectly will only result in a
larger and slower patch being generated.

### User interaction

BSP patches may have interactivity with the user in the form of displaying messages and menus. The patches generated
by bspbuild do use these capabilities, in the following ways:

* Displaying initial messages
* Displaying the detected source file
* Showing a menu for the user to select the desired target file
* Printing a message after the patch has finished successfully
* Showing an error message in case patching isn't successful

Various options allow controlling these interactions. By default, the initial and final messages are empty (and thus
not shown); however, the options `--opening-banner` and `--success-message` can be used to add a message to the patch.
Similarly, the default error message is a generic `Error: <error text>`; however, the `--error-message` option can be
used to override it. All of these options have a `-from-file` version (e.g., `--opening-banner-from-file`) that load
the message from a file instead of directly from the command line. Note that the message shown when an error occurs
can contain the error itself (in fact, the default message does this); this is specified as `###` in the message,
which is replaced by the error when displayed (and so, the default message can be obtained with `--error-message
"Error: ###"`). This placeholder can be changed using the `--error-text-substitute` option.

The detected source file is shown by default, as well as an error message if an error occurs. These messages can be
disabled using the `--suppress-source-message` and `--suppress-errors` options, respectively. Also, the default
message of `Detected input file: ` used to show the detected source file can be modified using the
`--source-detection-message` option.

If there are two or more possible target files, a menu will be presented for the user to select the target that they
want to generate. If there is only one possible target file, this menu is hidden by default; the `--force-output-menu`
option can be used to force this menu to appear anyway. Also, if there are too many targets to fit comfortably in a
single menu, the `--targets-per-page` option can be used to split the menu into multiple submenus containing between 2
and 15 targets each, as indicated in the option. (Note that the menu will only be split into pages if at least two
pages would be generated this way. Also, the last page may have one more target than the rest; a new page will not be
generated for just one target.) Finally, the `--sort-output-menu` option can be used to sort the target menu
alphabetically, instead of showing the targets in the order they are given in the command line.

Whenever a source or target is to be displayed, its filename is used by default. This can be overridden by specifying
a file containing names for each file involved; this is done with the `--titles` option. The format of this file will
be described in the corresponding section.

---

## Advanced features

In addition to the features described above, bspbuild contains a number of options intended for advanced users. All of
these options require specific command-line switches to enable them, and they are described in this section.

### BSP source code generation

As well as generating BSP patches, bspbuild can generate the source code corresponding to said patches. (This source
code is actually always generated as an intermediate step.) This is only of interest for those who know how to read
and/or modify BSP code.

The BSP code itself can be controlled by multiple options, as listed below:

* `--initial-register`: indicates the number of the lowest variable that the patch will use. The patch requires four
  variables, with consecutive numbers; the first one will be the one listed here. Valid values are 0-252; the default
  is 252.
* `--label-prefix`: indicates a string that will be prefixed to all labels declared in the source code. It defaults to
  an empty string; it should otherwise be a valid symbol name.
* `--register-prefix`, `--constant-prefix`: same as above, but for variable names and constant names.
* `--prefix`: indicates a generic prefix that will be used by all three kinds of names. The prefix will be used as
  given for labels; for constants, it will be converted to uppercase and words separated by underscores (so
  `SomePrefix` becomes `SOME_PREFIX_`); and for variables, it will use a lowercase variant of the constants version.

### Output validations

By default, the patch validates both its sources and its targets, by checking their size and SHA-1 hash. Validation of
input files cannot be disabled, since it is necessary to detect the input file that is being given to the patch;
however, output file validation is only an additional check. While this is not recommended, these validations can be
disabled for performance reasons: the `--no-output-validation` option does this, and the `--no-output-sha1-validation`
option disables the SHA-1 check while keeping the length check.

### Alternate execution modes

Since bspbuild includes a BSP compiler and an IPS patch creator by necessity, it makes those utilities available via
command-line options. Using these options disables bspbuild's main functionality, running the selected utility
instead.

These options are as follows:

* `--ips`: generates an IPS patch. The full command line must be of the form `bspbuild --ips <source> <target> -o
  <patch.ips>`. The source and target files must be at most 16 MB, and the target cannot be smaller than the source.
* `--bsp`: builds a BSP patch from source code; it can be used to build the source code generated by bspbuild (if the
  `-ob` option has been used to generate it), or any source file written by the user. The only option that can be used
  is `-o` to specify the target file; the full command line must be of the form `bspbuild --bsp <source code files> -o
  <target.bsp>`. Any number of source code files can be specified, and they will be compiled in the order given.

---
