# bspbuild documentation

bspbuild is a utility that aims to automatically create [BSP patches][bsp] automatically, removing the need to write
the patch's code manually. The patches created can validate both their inputs and outputs by checking their lengths
and SHA-1 hashes, and allow the user to use multiple input files and/or to select one of many possible outputs. The
data contained in the patches themselves may be stored in several different formats, thus allowing the patch creator
to select the best choice for each file involved.

Note that this utility is only concerned with creating patches, not with applying those patches. In order to apply a
patch created by this utility, you will need a BSP patcher, such as the one available [here][patcher].

[bsp]: https://github.com/aaaaaa123456789/bsp
[patcher]: https://aaaaaa123456789.github.io/bsp

## Table of contents

TODO

## Patching basics

### Inputs and outputs

A patch is, in general, a file that describes how to transform one file into another. While these files can be
respectively considered to be the input and output of the patching process, in order to avoid confusion with the
inputs and outputs of bspbuild itself, the remainder of these documentation will refer to these files as the _sources_
and _targets_ of the patch.

Therefore, a patch will contain instructions to turn one or more source files into one or more target files. Note that
patches built by bspbuild may involve more than one source or one target; if this is the case, the user of the patch
will be able to use any of the permitted source files to transform it into any of the target files.

Sources and targets are all treated as _inputs_ by bspbuild. That is because bspbuild must create a patch based on all
of these files; it reads them, but it doesn't write them. On the other hand, the patch is the _output_ of bspbuild.
The BSP source code that generates the patch can also be output by bspbuild.

### Sources and targets

As explained in the previous section, a patch generated by bspbuild may have arbitrarily many sources and targets. Due
to the differences between sources and targets, input files must be marked as sources, targets or both:

* The `-s` command-line option indicates that the input files that follow are source files. The patch will contain
  instructions to convert any of these files into the targets, and will accept any of them as input; however, the
  patch will be unable to regenerate and output these files.
* The `-t` command-line option indicates that the input files that follow are target files. The patch will contain
  instructions to generate any of these files from the sources; however, it will not accept these files as input.
* The `-st` command-line option indicates that the input files that follow are both sources and targets; this is the
  default if nothing is specified. The patch will contain instructions to convert any of these files into the targets,
  as well as instructions to convert any of the sources into these files; in other words, they can be both inputs and
  outputs of the patch. These files will be referred to as _source+target files_.

Note that, in order to generate a patch, at least one source and one target must be present. Source+target files count
as either. (However, a single source+target file by itself is not enough; there must be at least two input files.)

### Patching chains

If a patch involves multiple sources and targets, all of the targets must be buildable from all of the sources. By
default, this would involve storing information for each combination of source and target. In other words, each target
would require a patch that allows building it from every source â€” such a patch is often called a _rainbow patch_ in
the source code. This is undesirable due to space constraints.

In order to avoid creating rainbow patches when there is no need, bspbuild creates a _patching chain_. This chain
contains all source, source+target and target files in that order; for every file in the chain, a patch is stored
that transforms it into the next file in the chain. That way, every target can be built from every source without
having to store rainbow patches for all of them; the patches are applied in sequence and the chain is walked until the
desired file is obtained. Note that the patches involving source+target files are generated in such a way that allows
applying them in reverse, which enables the patch to walk that segment of the patching chain backwards in order to
generate earlier source+target files from later ones.

The fact that source files are involved in the patching chain implies that earlier source files can be transformed
into later ones by applying patches. While the patch doesn't emit these files (it will only emit files marked as
targets, i.e., source+target and target files), it does contain the data to do so. This may be undesirable in some
cases. If this is the case, the `--no-source-to-source` option disables source-to-source patches, removing source
files from the chain; in this case, a rainbow patch will be generated for the very first file in the chain, which may
be a source+target or a target file.

Target files are part of the chain. However, since they cannot ever be inputs to the patching process, a linear chain
is not necessary for them. Therefore, for targets other than the first, it is possible to indicate which file they
should be generated from, creating a tree-like structure at the end of the patching chain:

* The `-tp` option is the default, and indicates that subsequent target files should be generated from the previous
  target file, creating a linear chain.
* The `-tl` option indicates that the previously named target file should be taken as reference for generating all
  subsequent target files.
* The `-ts` option indicates that subsequent target files should be generated directly from the last source file. If
  the `--no-source-to-source` option is enabled and there are no source+target files, this generates rainbow patches
  for all subsequent target files.

Note that all of these options imply `-t`. Also, they can be given multiple times in the command line, each one coming
into force until a new one is given. This way, the end of the patching chain can be manipulated at will.

### Patching methods

A patching method is a specific data format for a patch. In other words, the patching method determines how the patch
data should be stored, and how it should be used to transform a file into another. Every individual patching method
requires a corresponding patching engine in order to apply its patches; bspbuild takes care to include all the
necessary patching engines in the patches it generates. Note that patching methods may have minor differences across
patches built by bspbuild depending on the configuration options passed to it; however, a single patching method will
not show any differences if used multiple times in the same BSP file.

The patching method used to generate each file in the patching chain can be selected by the user; this is true
irrespective of whether a file is a source, source+target or target file. (Files removed from the patching chain by
the `--no-source-to-source` option, as well as the very first source file (or source+target file, if there are no
source files) ignore the selected patching method, as they are never outputs to any patch.

The patching method is selected using the `-m` option (for instance, `-m ips` selects the `ips` patching method); the
selected method applies for all subsequent files until a new method is selected. The available patching methods are:

* `ips`: generates IPS-like patches (modified to allow patches for files larger than 16 MB, as well as patches that
  generate smaller files than the original). These patches are not naturally reversible, which means that a reversible
  IPS patch will be stored as two separate patches.
* `xor`: generates a patch where the data is stored as the XOR between the two files involved. This has the same size
  as the larger of the two files, and is equivalent to encrypting one of the files using the other as key.
* `xor-rle` (default): generates a patch where the data is computed as the XOR between the two files involved, but
  then stored in a format that encodes runs of equal values and arithmetical sequences in a compact format, thus
  usually resulting in a smaller patch.

### Fragmentation and padding

If a file is internally made up of multiple smaller blocks of equal size (called _fragments_), it may be useful to
indicate this fact to the patch builder; this will adapt the patching method to handle each fragment separately. This
allows for smaller and better patches to be generated, particularly when combined with the options explained below.
The fragment size is indicated with the `-f` option; for instance, `-f 16384` indicates that the file should be broken
into 16 KB fragments. (The smallest valid size is 64; however, using this option with fragments smaller than a few
kilobytes in size is not recommended.)

If the target file in question is a file that has been padded up to its current size, this can be indicated to produce
a smaller patch. The options `-pb`, `-ph` and `-pw` respectively accept an 8, 16 or 32-bit value as an argument, and
indicate that the file has been padded with that value; for instance, `-pb 0xff` indicates that the file has been
padded with FF bytes. If fragmentation is enabled, each individual fragment is considered to be padded to length;
therefore, the padding at the end of each fragment may be omitted.

If the fragments in the target file are not in the same order as in the source file, the patching method can be
adapted to take this into account; the `--check-fragment-swap` option does this. This will add an initial pass of
fragment reordering before applying the patch.

Note that patching methods may or may not take the information given by these options into account; for instance, the
`ips` method ignores it. Also note that misuse of these options will not generate incorrect patches â€” these options
are intended as optimizations to produce smaller and faster patches, but using them incorrectly will only result in a
larger and slower patch being generated.
