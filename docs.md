# bspbuild documentation

bspbuild is a utility that aims to automatically create [BSP patches][bsp] automatically, removing the need to write
the patch's code manually. The patches created can validate both their inputs and outputs by checking their lengths
and SHA-1 hashes, and allow the user to use multiple input files and/or to select one of many possible outputs. The
data contained in the patches themselves may be stored in several different formats, thus allowing the patch creator
to select the best choice for each file involved.

Note that this utility is only concerned with creating patches, not with applying those patches. In order to apply a
patch created by this utility, you will need a BSP patcher, such as the one available [here][patcher].

[bsp]: https://github.com/aaaaaa123456789/bsp
[patcher]: https://aaaaaa123456789.github.io/bsp

---

## Table of contents

* [Patching basics][section-basics]
    * [Inputs and outputs][section-IO]
    * [Sources and targets][section-sources-targets]
    * [Patching chains][section-chains]
    * [Patching methods][section-methods]
    * [Fragmentation and padding][section-fragmentation]
    * [User interaction][section-interaction]
* [Advanced features][section-advanced]
    * [BSP source code generation][section-source]
    * [Output validations][section-validations]
    * [Alternate execution modes][section-alternate]
* [Command-line usage][section-command-line]
    * [Simple examples][section-examples]
    * [Full command-line syntax and options][section-syntax]
    * [Titles file format][section-titles]

[section-basics]: #patching-basics
[section-IO]: #inputs-and-outputs
[section-sources-targets]: #sources-and-targets
[section-chains]: #patching-chains
[section-methods]: #patching-methods
[section-fragmentation]: #fragmentation-and-padding
[section-interaction]: #user-interaction
[section-advanced]: #advanced-features
[section-source]: #bsp-source-code-generation
[section-validations]: #output-validations
[section-alternate]: #alternate-execution-modes
[section-command-line]: #command-line-usage
[section-examples]: #simple-examples
[section-syntax]: #full-command-line-syntax-and-options
[section-titles]: #titles-file-format

---

## Patching basics

### Inputs and outputs

A patch is, in general, a file that describes how to transform one file into another. While these files can be
respectively considered to be the input and output of the patching process, in order to avoid confusion with the
inputs and outputs of bspbuild itself, the remainder of these documentation will refer to these files as the _sources_
and _targets_ of the patch.

Therefore, a patch will contain instructions to turn one or more source files into one or more target files. Note that
patches built by bspbuild may involve more than one source or one target; if this is the case, the user of the patch
will be able to use any of the permitted source files to transform it into any of the target files.

Sources and targets are all treated as _inputs_ by bspbuild. That is because bspbuild must create a patch based on all
of these files; it reads them, but it doesn't write them. On the other hand, the patch is the _output_ of bspbuild.
The BSP source code that generates the patch can also be output by bspbuild.

### Sources and targets

As explained in the previous section, a patch generated by bspbuild may have arbitrarily many sources and targets. Due
to the differences between sources and targets, input files must be marked as sources, targets or both:

* The `-s` command-line option indicates that the input files that follow are source files. The patch will contain
  instructions to convert any of these files into the targets, and will accept any of them as input; however, the
  patch will be unable to regenerate and output these files.
* The `-t` command-line option indicates that the input files that follow are target files. The patch will contain
  instructions to generate any of these files from the sources; however, it will not accept these files as input.
* The `-st` command-line option indicates that the input files that follow are both sources and targets; this is the
  default if nothing is specified. The patch will contain instructions to convert any of these files into the targets,
  as well as instructions to convert any of the sources into these files; in other words, they can be both inputs and
  outputs of the patch. These files will be referred to as _source+target files_.

Note that, in order to generate a patch, at least one source and one target must be present. Source+target files count
as either. (However, a single source+target file by itself is not enough; there must be at least two input files.)

### Patching chains

If a patch involves multiple sources and targets, all of the targets must be buildable from all of the sources. By
default, this would involve storing information for each combination of source and target. In other words, each target
would require a patch that allows building it from every source — such a patch is often called a _rainbow patch_ in
the source code. This is undesirable due to space constraints.

In order to avoid creating rainbow patches when there is no need, bspbuild creates a _patching chain_. This chain
contains all source, source+target and target files in that order; for every file in the chain, a patch is stored
that transforms it into the next file in the chain. That way, every target can be built from every source without
having to store rainbow patches for all of them; the patches are applied in sequence and the chain is walked until the
desired file is obtained. Note that the patches involving source+target files are generated in such a way that allows
applying them in reverse, which enables the patch to walk that segment of the patching chain backwards in order to
generate earlier source+target files from later ones.

The fact that source files are involved in the patching chain implies that earlier source files can be transformed
into later ones by applying patches. While the patch doesn't emit these files (it will only emit files marked as
targets, i.e., source+target and target files), it does contain the data to do so. This may be undesirable in some
cases. If this is the case, the `--no-source-to-source` option disables source-to-source patches, removing source
files from the chain; in this case, a rainbow patch will be generated for the very first file in the chain, which may
be a source+target or a target file.

Target files are part of the chain. However, since they cannot ever be inputs to the patching process, a linear chain
is not necessary for them. Therefore, for targets other than the first, it is possible to indicate which file they
should be generated from, creating a tree-like structure at the end of the patching chain:

* The `-tp` option is the default, and indicates that subsequent target files should be generated from the previous
  target file, creating a linear chain.
* The `-tl` option indicates that the previously named target file should be taken as reference for generating all
  subsequent target files.
* The `-ts` option indicates that subsequent target files should be generated directly from the last source file. If
  the `--no-source-to-source` option is enabled and there are no source+target files, this generates rainbow patches
  for all subsequent target files.

Note that all of these options imply `-t`. Also, they can be given multiple times in the command line, each one coming
into force until a new one is given. This way, the end of the patching chain can be manipulated at will.

### Patching methods

A patching method is a specific data format for a patch. In other words, the patching method determines how the patch
data should be stored, and how it should be used to transform a file into another. Every individual patching method
requires a corresponding patching engine in order to apply its patches; bspbuild takes care to include all the
necessary patching engines in the patches it generates. Note that patching methods may have minor differences across
patches built by bspbuild depending on the configuration options passed to it; however, a single patching method will
not show any differences if used multiple times in the same BSP file.

The patching method used to generate each file in the patching chain can be selected by the user; this is true
irrespective of whether a file is a source, source+target or target file. (Files removed from the patching chain by
the `--no-source-to-source` option, as well as the very first source file (or source+target file, if there are no
source files) ignore the selected patching method, as they are never outputs to any patch.)

The patching method is selected using the `-m` option (for instance, `-m ips` selects the `ips` patching method); the
selected method applies for all subsequent files until a new method is selected. The available patching methods are:

* `ips`: generates IPS-like patches (modified to allow patches for files larger than 16 MB, as well as patches that
  generate smaller files than the original). These patches are not naturally reversible, which means that a reversible
  IPS patch will be stored as two separate patches.
* `xor`: generates a patch where the data is stored as the XOR between the two files involved. This has the same size
  as the larger of the two files, and is equivalent to encrypting one of the files using the other as key.
* `xor-rle` (default): generates a patch where the data is computed as the XOR between the two files involved, but
  then stored in a format that encodes runs of equal values and arithmetical sequences in a compact format, thus
  usually resulting in a smaller patch.

### Fragmentation and padding

If a file is internally made up of multiple smaller blocks of equal size (called _fragments_), it may be useful to
indicate this fact to the patch builder; this will adapt the patching method to handle each fragment separately. This
allows for smaller and better patches to be generated, particularly when combined with the options explained below.
The fragment size is indicated with the `-f` option; for instance, `-f 16384` indicates that the file should be broken
into 16 KB fragments. (The smallest valid size is 64; however, using this option with fragments smaller than a few
kilobytes in size is not recommended.)

If the target file in question is a file that has been padded up to its current size, this can be indicated to produce
a smaller patch. The options `-pb`, `-ph` and `-pw` respectively accept an 8, 16 or 32-bit value as an argument, and
indicate that the file has been padded with that value; for instance, `-pb 0xff` indicates that the file has been
padded with FF bytes. If fragmentation is enabled, each individual fragment is considered to be padded to length;
therefore, the padding at the end of each fragment may be taken into account by the patching method and omitted from
the generated patch data.

If the fragments in the target file are not in the same order as in the source file, the patching method can be
adapted to take this into account; the `--check-fragment-swap` option does this. This will add an initial pass of
fragment reordering before applying the patch.

Note that patching methods may or may not take the information given by these options into account; for instance, the
`ips` method ignores it. Also note that misuse of these options will not generate incorrect patches — these options
are intended as optimizations to produce smaller and faster patches, but using them incorrectly will only result in a
larger and slower patch being generated.

### User interaction

BSP patches may have interactivity with the user in the form of displaying messages and menus. The patches generated
by bspbuild do use these capabilities, in the following ways:

* Displaying initial messages
* Displaying the detected source file
* Showing a menu for the user to select the desired target file
* Printing a message after the patch has finished successfully
* Showing an error message in case patching isn't successful

Various options allow controlling these interactions. By default, the initial and final messages are empty (and thus
not shown); however, the options `--opening-banner` and `--success-message` can be used to add a message to the patch.
Similarly, the default error message is a generic `Error: <error text>`; however, the `--error-message` option can be
used to override it. All of these options have a `-from-file` version (e.g., `--opening-banner-from-file`) that load
the message from a file instead of directly from the command line. Note that the message shown when an error occurs
can contain the error itself (in fact, the default message does this); this is specified as `###` in the message,
which is replaced by the error when displayed (and so, the default message can be obtained with `--error-message
"Error: ###"`). This placeholder can be changed using the `--error-text-substitute` option.

The detected source file is shown by default, as well as an error message if an error occurs. These messages can be
disabled using the `--suppress-source-message` and `--suppress-errors` options, respectively. Also, the default
message of `Detected input file: ` used to show the detected source file can be modified using the
`--source-detection-message` option.

If there are two or more possible target files, a menu will be presented for the user to select the target that they
want to generate. If there is only one possible target file, this menu is hidden by default; the `--force-output-menu`
option can be used to force this menu to appear anyway. Also, if there are too many targets to fit comfortably in a
single menu, the `--targets-per-page` option can be used to split the menu into multiple submenus containing between 2
and 15 targets each, as indicated in the option. (Note that the menu will only be split into pages if at least two
pages would be generated this way. Also, the last page may have one more target than the rest; a new page will not be
generated for just one target.) Finally, the `--sort-output-menu` option can be used to sort the target menu
alphabetically, instead of showing the targets in the order they are given in the command line.

Whenever a source or target is to be displayed, its filename is used by default. This can be overridden by specifying
a file containing names for each file involved; this is done with the `--titles` option. The format of this file will
be described in [the corresponding section][section-titles]. Alternately, this data can be given through the standard
input; this is indicated through the `--titles-from-stdin` option.

---

## Advanced features

In addition to the features described above, bspbuild contains a number of options intended for advanced users. All of
these options require specific command-line switches to enable them, and they are described in this section.

### BSP source code generation

As well as generating BSP patches, bspbuild can generate the source code corresponding to said patches. (This source
code is actually always generated as an intermediate step.) This is only of interest for those who know how to read
and/or modify BSP code.

The BSP code itself can be controlled by multiple options, as listed below:

* `--initial-register`: indicates the number of the lowest variable that the patch will use. The patch requires four
  variables, with consecutive numbers; the first one will be the one listed here. Valid values are 0-252; the default
  is 252.
* `--label-prefix`: indicates a string that will be prefixed to all labels declared in the source code. It defaults to
  an empty string; it should otherwise be a valid symbol name.
* `--register-prefix`, `--constant-prefix`: same as above, but for variable names and constant names.
* `--prefix`: indicates a generic prefix that will be used by all three kinds of names. The prefix will be used as
  given for labels; for constants, it will be converted to uppercase and words separated by underscores (so
  `SomePrefix` becomes `SOME_PREFIX_`); and for variables, it will use a lowercase variant of the constants version.

### Output validations

By default, the patch validates both its sources and its targets, by checking their size and SHA-1 hash. Validation of
input files cannot be disabled, since it is necessary to detect the input file that is being given to the patch;
however, output file validation is only an additional check. While this is not recommended, these validations can be
disabled for performance reasons: the `--no-output-validation` option does this, and the `--no-output-sha1-validation`
option disables the SHA-1 check while keeping the length check.

### Alternate execution modes

Since bspbuild includes a BSP compiler and an IPS patch creator by necessity, it makes those utilities available via
command-line options. Using these options disables bspbuild's main functionality, running the selected utility
instead.

These options are as follows:

* `--ips`: generates an IPS patch. The full command line must be of the form `bspbuild --ips <source> <target> -o
  <patch.ips>`. The source and target files must be at most 16 MB, and the target cannot be smaller than the source.
* `--bsp`: builds a BSP patch from source code; it can be used to build the source code generated by bspbuild (if the
  `-ob` option has been used to generate it), or any source file written by the user. The only option that can be used
  is `-o` to specify the target file; the full command line must be of the form `bspbuild --bsp <source code files> -o
  <target.bsp>`. Any number of source code files can be specified, and they will be compiled in the order given.

---

## Command-line usage

### Simple examples

* Build a patch between two files: `bspbuild file1.dat file2.dat -o patch.bsp`. Since the files are source+target
  files by default, this patch will allow generating either of the files from the other one.
* In order to ensure that `file1.dat` is the source and `file2.dat` is the target, do `bspbuild -s file1.dat -t
  file2.dat -o patch.bsp`.
* If the patch should be able to generate both `file2.dat` and `file3.dat`, then `bspbuild -s file1.dat -t file2.dat
  file3.dat -o patch.bsp` will achieve that. If the patch should also be able to patch `file2.dat` and `file3.dat`
  into one another, then they should be made source+target files, by using `-st` instead of `-t`.
* It may be desirable to use an IPS patch between the two target files in the example above, instead of a XOR RLE
  patch (the default); this is particularly the case when the differences between those two files are very small.
  Since the patching method only applies to the target of a link in the patching chain, this effect is achieved by
  `bspbuild -s file1.dat -t file2.dat -m ips file3.dat -o patch.bsp`.
* In any of the above examples, if the goal is to obtain BSP code instead of a compiled patch, the `-ob` option
  should be used instead of `-o`. It is also possible to use both options, in which case two files will be generated.

### Full command-line syntax and options

```
bspbuild [<options>] [--] [<input files>]
```

Note that, despite the syntax shown above, options and input files can be freely mixed — any command-line argument not
bound to an option will be considered an input file. Command-line arguments beginning with `-` will be considered
options by default. At least two input files must be given.

Valid options are listed below. Note that short options may **not** be combined (e.g., `-st` is not the same as `-s
-t`).

**Escaping:**

* `--`: indicates the end of the option list. All further command-line arguments will be interpreted as input files.
* `-$`: indicates that the next command-line argument must be interpreted as an input file, regardless of whether it
  begins with `-`.

**Help and version:**

Any of these options will cause bspbuild to print the corresponding text and exit successfully. A short message will
also be printed if no command-line options at all are given.

* `--version`: prints the program's current version number and a legal disclaimer.
* `--help`: prints a help message.

**Input file types:**

* `-s`, `--source`: specifies that the input files that follow are source files.
* `-st`, `--source-target`: specifies that the input files that follow are source+target files (default).
* `-t`, `--target`: specifies that the input files that follow are target files.

**Output files:**

* `-o <file>`: indicates that the compiled patch must be written to the indicated file.
* `-ob <file>`: indicates that the BSP source code for the patch must be written to the indicated file.

**Target references:**

All of the following options imply `-t`.

* `-tl`, `--target-from-last`: specifies that the target files that follow must be built linearly from the file that
  precedes them.
* `-tp`, `--target-from-previous`: specifies that the target files that follow must be built from the last input file
  named before this option (which must be a target file).
* `-ts`, `--target-from-source`: specifies that the target files that follow must be built directly from source or
  source+target files.

**Patching options:**

* `-m <method name>`, `--patch-method <method name>`: specifies the patching method for the input files that follow.
  The method name must be one of the patching methods described in [the corresponding section][section-methods].
* `--no-source-to-source`: indicates that source files must not be included in the patching chain, therefore not
  generating any patch data that would allow to reconstruct one source file from another.
* `--no-output-validation`: indicates that the length and SHA-1 hash of the file generated by the patch must not be
  validated.
* `--no-output-sha1-validation`: indicates that the SHA-1 hash of the file generated by the patch must not be
  validated. The length of the file will still be checked.

**Fragmentation and padding:**

Note that the values given as arguments to these options may be decimal, hexadecimal (preceded by `0x`) or octal
(preceded by `0`). Therefore, `16384`, `0x4000` and `040000` indicate the same value. All of these options are purely
optimization hints for the patching methods to use.

* `-f <fragment size>`: indicates that the input files consist of fragments of the specified size, which is given in
  bytes and must be at least 64.
* `-p <value>`, `pw <value>`: indicates that input files (or their fragments, if `-f` is given) are padded to size
  using the 32-bit value given as an argument to this option.
* `-ph <value>`: same as above, for a 16-bit value.
* `-pb <value>`: same as above, for an 8-bit value.
* `--check-fragment-swap`: indicates that the order of the fragments may change between input files, and therefore
  they should be reordered prior to patching.

**User messages:**

All of these options control the messages shown by the compiled patch to the user.

* `--opening-banner <message>`: indicates a message that will be shown to the user as the patch starts. (By default,
  no message is shown.)
* `--success-message <message>`: indicates a message that will be shown to the user if patching is successful. (By
  default, no message is shown.)
* `--error-message <message>`: indicates a message that will be shown to the user if an error occurs while patching.
  The default message is `Error: ###`, where `###` is substituted with the actual error text.
* `--opening-banner-from-file <file>`, `--success-message-from-file <file>`, `--error-message-from-file <file>`:
  versions of the options listed above that load the message from a file instead of specifying it directly in the
  command line.
* `--error-text-substitute <text>`: indicates the text that will be substituted with the actual error text in the
  error message defined above. The default is `###`.
* `--suppress-errors`: disables the display of error messages to the user.
* `--hide-errors`: alias for the above option.
* `--source-detection-message <message>`: indicates the message that will be shown after detecting and validating the
  patch's input file; the name (or title, if given) of the detected file will be appended to this message. The default
  is `Detected input file: `.
* `--suppress-source-message`: disables the display of the message described by the previous option.

**User prompts:**

These options control the prompts that will be shown to the user. The user will be prompted to select the output file
that they want when multiple options are available.

* `--titles <file>`: indicates a file containing title information for the input files. File titles will be used
  instead of file names if they are available in user messages and prompts. The format of this file will be described
  [in a separate section][section-titles].
* `--titles-from-stdin`: indicates that title information for input files (as described for the previous option)
  should be read from standard input. The format of this data is identical.
* `--sort-output-menu`: sorts the output file menu alphabetically, instead of in the order given in the command line.
  If this option is not given, files will appear in the order they are named in the command line, with source+target
  files appearing before target files.
* `--force-output-menu`: forces the output selection menu to be shown, even when only one option can be selected.
* `--targets-per-page <value>`: splits the output selection menu into multiple pages, having as many targets per page
  as specified in this option's argument; that value must be between 2 and 15. The last page may have one more target
  than the rest; a new page will only be created if at least two targets would go on it. This option is ignored if it
  would result in only one page of targets.

**BSP source code options:**

These options control the generation of BSP source code. They are only of interest for people who intend to inspect or
edit the generated patch.

* `--initial-register <value>`: indicates the lowest numbered variable that will be used by the generated patch; the
  patch uses four variables, starting at the one specified by this option's argument. The value must be between 0 and
  252 and defaults to 252.
* `--label-prefix <prefix>`, `--constant-prefix <prefix>`, `--register-prefix <prefix>`: indicate prefixes to be
  prepended to label names, constant names and named variable names. These prefixes must all be valid identifiers, and
  they default to being empty. Prefixes may be used to avoid collision between the generated patch code and other user
  code included in the same patch.
* `--prefix <prefix>`: uses a single prefix, adapted as indicated [in the corresponding section][section-source]. This
  option cannot be combined with any of the options described in the previous list item.

**Alternate execution modes:**

These options invoke utilities included in bspbuild, disabling the main functionality of bspbuild itself. They cannot
be combined with any other option except `-o` (which is used to indicate the location of the output file).

* `--bsp`: invokes the BSP compiler. At least one input file must be given; if more than one is specified, they will
  be compiled in the order given. The input files must contain BSP source code, and the output will be a compiled BSP
  patch.
* `--ips`: invokes the IPS patch generator. Exactly two input files must be given, which will be the source and target
  of the IPS patch; they cannot be larger than 16 MB, and the source cannot be larger than the target. The output will
  be an IPS patch.

### Titles file format

This section describes the format of the file titles file. This is the file that is passed to the `--titles` option as
its argument, or the contents of the standard input if the `--titles-from-stdin` option is used.

The purpose of said file is to assign a user-friendly title to each input file (source, source+target or target) to be
shown to patch users. This file contains one line per input file to name; blank lines are ignored. Also, lines
beginning with `//` are considered comments. Note that whitespace is significant, as it will be considered part of
filenames or titles.

Each line can be _labelled_ or _unlabelled_. A labelled line gives a title for a specific file; the filename must be
specified exactly as given in the command line. These lines take the form `filename=title` (without any whitespace
surrounding the `=`), and the title in question will only be used for the named file.

Unlabelled lines are those that don't begin with a filename. Unlabelled lines may also begin with a `=` sign (that is
ignored); this will escape any further `=` signs that occur in the title. After all labelled lines are parsed and the
corresponding files are given their titles, the remaining files will be assigned titles from unlabelled lines, in the
order they are given in the command line (source files first, then source+target files, and finally target files).

The following is a sample valid titles file:

```
// name the source file
input.dat=Input File

// name the source+target files
Second File
Third File
Fourth File

// name the target files
=FIFTH==FILE
output.dat=SIXTH==FILE
```

For the command line `bspbuild -s input.dat -st file2.dat file3.dat file4.dat -t file5.dat output.dat -o patch.bsp
--titles titles.txt`, this will assign the titles in the order given. (It is not necessary to use such a random mix of
labelled and unlabelled lines; they are shown here for the example.) Note that the title for `file5.dat` will be
`FIFTH==FILE`; the initial `=` is an escape character that signals that the line is unlabelled. If that `=` character
had been omitted, bspbuild would look for a file called `FIFTH` and assign the title `=FILE` to it.

If some labelled lines don't match any files, they are ignored; excess unlabelled lines are likewise ignored. If there
are too few unlabelled lines (including the case where there are none at all), the leftover files will not be assigned
a title.

---
